========================================================================
    STATIC LIBRARY : tblib Project Overview
	Author : Boris Telesnin
	Language: C++ 
	2010 - 2020 years
========================================================================
проект: msvc2015\tblib.vcxproj

Я начал программировать на С++ до появления  windows XP. Тогда, время которое  требовалось для сборки "невеликого" проекта было сравнимо с временем перекура. Это наложило серьезный отпечаток на мои отношения с С++. Долгое время (еще лет 10) я предпочитал писать на Delphi, только изза времени компиляции и сборки. Даже в настоящее время, если мне приходится писать на С++ , я предпочитаю по возможности избегать стандартных библиотек, в том числе сторонних (например boost). В своих проектах я редко использую std::string std::vector (только для сопряжения). 

Строки и массивы.
Когда то я любил Delphi. И в память о его конструкциях сделал себе подобие строк и массивов в C++.
 gdata/tbt_strings.h  - строки и массивы
 gdata/tb_parray.h    - слайсы строк и массивов
 gdata/gen_tools.h	  - вспомогательные операторы и функции для строк. Сравнение, преобразования , слияния (формат)  	
 
 
Строки и массивы это шаблонные классы (lstring и darray) , производные от шаблона c_basic_array<t_TChar , c_mode>. Шаблонный параметр 
c_mode определяет тип класса: строка или массив. 
Разница между строкой и массивом: 
	- Элементы строки - это бинарные данные. Элементы массива могут иметь конструкторы, и могут быть не перемещаемыми в памяти.Если элементы не перемещаемы, используется поэлементное копирование (при перемещении элемента массива в памяти)
	- Строка всегда завершается символом 0, при этом терминальный символ не влияет на размер строки.
	- При попытке изменения символа строки, строка становится уникальной. Массив станет уникальным только при изменении его размера. 
Строки и массивы имеют много общего с интерфейсом соответсвующих обектов std: size,begin,end,data и т.п. 	
	
Хранение: Структура хранения обоих типов позаимствована из Delphi. Строка (массив), хранит указатель сразу на данные. Адрес служебной информации ( структура _string_header: размер,количество ссылок ) меньше адреса данных на 12 байт. Объект хранит данные (живет) до достижения счетчиком ссылок значения 0 (reference counting). Данные ( и _string_header) всегда храняться в динамической памяти. Почему?  Delphi хранил небольшие объекты (размером до 4*1024 байт) в хипе по алгоритму "близнецов" - это было достаточно эффективно. Системные библиотеки (winapi HeapAlloc, HeapFree) не использовались. В msvc используется winapi(HeapAlloc, HeapFree), я не смотрел реализацию, но при разработке полагал, что в крайних вариантах, для увеличения быстродействия обращения к хипу можно перехватить и добавить туда алгоритм близнецов.

Когда я познакомился с языком Golang, я понял что для эффективной работы со строками в С++ (в части минимизации выделения памяти), необходимы слайсы.
Слайсы строк существенно увеличили быстродействие например при парсинге текстовых файлов (json,xml и т.п.). Слайсы реализованы в файле gdata/tb_parray.h. В моем варианте, объект слайс состоит из объекта (lstring и darray) и двух указателей , на начало и конец данных. При этом пришлось повторить часть работы по обеспечению : новые операторы сравнения, и другие полезные перегрузки.

========================================================================
 Кроссплатформенность
 Код нуждающийся в реализации на разных платформах (Linux и Windows), расположен в каталоге tsys.
 Код который получился, показал что вполне возможно избавиться от сторонних библиотек для кроссплатформенности. Последние обычно исльно увеличивают время сборки и компиляции проекта (тот же boost). если честно, у меня просто нехватало терпения и здоровья компиляться с бустом ( Слишком много перекуров )
 
 tsys\systime.cpp  - работа с временем и датой
 tsys\tbfiles.cpp  - работа с файлами и каталогами
 tsys\tb_ssockets.cpp - работа с сетевыми сокетами
 tsys\tb_process.cpp  - работа с процессами
 tsys\sys_mutex.h  	   - средства синхронизации
 tsys\cross_sys.cpp   - всякое , в том числе поддержка thread 
 
==============================
 Макросы.

Я не часто делаю макросы. После знакомства с TASM, макросы в С++ уважения не вызывали( Макросы в TASM обладают способностью описать например новый ассемблер). Но тем не менее и в С++ они могут облегчить жизнь.
Приведу макросы которые часто используются в этой библиотеке:
 
#define AUTOENTER(a) // - вход в мьютекс  реализация в файле tsys\sys_mutex.h
#define ARRAYLEN( a ) (sizeof(a)/sizeof(a[0])) // возвращает размер статического массива
#define FOREACH( It , St) for(auto It=St.begin();It!=St.end();It++)

Полезность макросов я покажу на примере макроса AUTOENTER.
Если нам нужно сделать потоково безопасное обращение к данным, через мьютекс , то обычно мы пишем следующий код
Пусть мьютекс уже существует в переменной mut. И у нас есть класс обертка entrleave , назначение которого состоит в вызове методов enter/leave (или lock/unlock) мьютекса, из конструктора и деструктора соответственно. Тогда код выглядит примерно так
{ entrleave NewVar( mut );
	...
}
Что не так в этом коде? Переменная NewVar, не будет нигде использованна, она упоминается всего один раз, но при этом, каждый раз - ее надо придумывать. Как избежать придумывания никому не нужных имен?
С++ позволяет придумывать имена с помощью макросов.  Макрос AUTOENTER( mut )создаст имя  mut__COUNTER__, и его использование будет эквивалентно коду
entrleave mut__COUNTER__( mut );
В итоге код для входа в мьютекс , у меня всегда выглядит так: 
{ AUTOENTER( mut );
	...
}




