#include "tbt_locale.h"

#define _CROSS_SYS_COD
// ------------------------ code page support --------------------------
#include <tsys/cross_sys.h>

#ifdef _WIN32
//#include <time.h>
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
//#include <Winsock2.h>

#else  // linux


//#include <dlfcn.h>
//#include <time.h>
//#include <sys/time.h>
//#include <sys/times.h>
//#include <unistd.h>
#include <libgen.h>
#include <sys/utsname.h>

#endif


/*
#ifdef _WINDOWS
static int do_strnicmp_l( const char * l , const char * r , size_t sz ){
if (get_char_codepage_type()==eUTF8) return _strnicmp( l,  r, sz );
return _strnicmp_l( l,  r, sz , getDefaultLocale());
};
static int do_strnicmp_l( const wchar_t * l , const wchar_t * r , size_t sz ){
return _wcsnicmp_l( l,  r, sz , getDefaultLocale()); };
#else
static int do_strnicmp_l( const char * l , const char * r , size_t sz ){
return strncasecmp(l,  r, sz);
};
static int do_strnicmp_l( const wchar_t * l , const wchar_t * r , size_t sz ){
return do_strnicmp_ll( l,  r, sz ); };
#endif
*/


namespace tbgeneral {

#ifdef _WINDOWS

int setconsoleCP_utf8() {
	SetConsoleOutputCP(CP_UTF8);
	return 0;
};

int encode_str_to_consoleCP(char * dest, size_t dsz, const char * src) {
	if (get_char_codepage_type() == eUTF8) {
		memcpy(dest, src, std::min<size_t>(dsz, strlen(src)));
	};
	return CharToOemA(src, dest);
};

#else 

int setconsoleCP_utf8() {
	return 0;
};


int encode_str_to_consoleCP(char * dest, size_t dsz, const char * src) {
	//return cpen_defCP2koi8(dest , src);
	/*
	if (!dsz) return 0;
	std::string r = Convert_1251toUtf8(src, strlen(src));
	uint sz = tbgeneral::min<int>(r.size(), dsz - 1);
	memcpy(dest, r.cbegin(), sz);
	dest[sz] = 0;
	return sz;
	*/
	auto sz = std::min<size_t>(dsz, strlen(src));
	memcpy(dest, src, sz );
	return sz;
};

#endif


// default locale <> utf16 (widechar)

size_t utf16_to_deflocale(char* ws, size_t csize, const wchar_t* src, size_t src_size) {
	//TODO:!
	return snprintf(ws, csize, "%S", src);
};

#ifdef _WINDOWS
//----------------- UPPER/LOWER CASE -----------------------

static _locale_t default_locale = 0;// = _create_locale(LC_ALL , "");
_locale_t  getDefaultLocale() { if (!default_locale) { default_locale = _create_locale(LC_ALL, ""); }; return default_locale; };

size_t deflocale_to_utf16(wchar_t* ws, size_t wsize, const char* src, size_t src_size) {
	//TODO: !
	return _swprintf_l(ws, wsize , L"%S", getDefaultLocale(), src );
}

/*
static wchar_t* do_wprintf_locale(wchar_t* buff, size_t buffsize, const wchar_t* format, const char* src) {
	_swprintf_l(buff, buffsize, L"%S", getDefaultLocale(), src);
	//swprintf( &dst[0] , dst.size()+1 , L"%S" , src );
	return buff;
}
*/

#else 
size_t deflocale_to_utf16(wchar_t* ws, size_t wsize, const char* src, size_t src_size) {
	//TODO: !
	return swprintf(ws, wsize, L"%S", src);
}
/*
static wchar_t* do_wprintf_locale(wchar_t* buff, size_t buffsize, const wchar_t* format, const char* src) {
	swprintf(buff, buffsize, L"%S", src);
	return buff;
}*/
#endif

//----------------- 1251 <> utf16 -----------------------

#ifdef _WINDOWS




std::string Convert_1251toUtf8(const char* data, int len) {
	if (len<0) len = (int)strlen(data);
	darray<wchar_t> buf; buf.resize(len * 3);
	int t = MultiByteToWideChar(CP_ACP, 0, data, -1, buf.data(), len * 3);
	std::string ret(len * 3, 0);
	int t2 = WideCharToMultiByte(CP_UTF8, 0, buf.data(), t, const_cast<char*>(ret.data()), len * 3, 0, 0);
	ret.resize(t2);
	return ret;
};

#else 



std::string Convert_1251toUtf8(const char* data, int len) {
	static const byte utf8enc1251[128][4] = {
		{ 0xD0, 0x82, 0x00 },{ 0xD0, 0x83, 0x00 },{ 0xE2, 0x80, 0x9A, 0x00 },{ 0xD1, 0x93, 0x00 },
		{ 0xE2, 0x80, 0x9E, 0x00 },{ 0xE2, 0x80, 0xA6, 0x00 },{ 0xE2, 0x80, 0xA0, 0x00 },{ 0xE2, 0x80, 0xA1, 0x00 },
		{ 0xE2, 0x82, 0xAC, 0x00 },{ 0xE2, 0x80, 0xB0, 0x00 },{ 0xD0, 0x89, 0x00 },{ 0xE2, 0x80, 0xB9, 0x00 },
		{ 0xD0, 0x8A, 0x00 },{ 0xD0, 0x8C, 0x00 },{ 0xD0, 0x8B, 0x00 },{ 0xD0, 0x8F, 0x00 },
		{ 0xD1, 0x92, 0x00 },{ 0xE2, 0x80, 0x98, 0x00 },{ 0xE2, 0x80, 0x99, 0x00 },{ 0xE2, 0x80, 0x9C, 0x00 },
		{ 0xE2, 0x80, 0x9D, 0x00 },{ 0xE2, 0x80, 0xA2, 0x00 },{ 0xE2, 0x80, 0x93, 0x00 },{ 0xE2, 0x80, 0x94, 0x00 },
		{ 0xC2, 0x98, 0x00 },{ 0xE2, 0x84, 0xA2, 0x00 },{ 0xD1, 0x99, 0x00 },{ 0xE2, 0x80, 0xBA, 0x00 },
		{ 0xD1, 0x9A, 0x00 },{ 0xD1, 0x9C, 0x00 },{ 0xD1, 0x9B, 0x00 },{ 0xD1, 0x9F, 0x00 },
		{ 0xC2, 0xA0, 0x00 },{ 0xD0, 0x8E, 0x00 },{ 0xD1, 0x9E, 0x00 },{ 0xD0, 0x88, 0x00 },
		{ 0xC2, 0xA4, 0x00 },{ 0xD2, 0x90, 0x00 },{ 0xC2, 0xA6, 0x00 },{ 0xC2, 0xA7, 0x00 },
		{ 0xD0, 0x81, 0x00 },{ 0xC2, 0xA9, 0x00 },{ 0xD0, 0x84, 0x00 },{ 0xC2, 0xAB, 0x00 },
		{ 0xC2, 0xAC, 0x00 },{ 0xC2, 0xAD, 0x00 },{ 0xC2, 0xAE, 0x00 },{ 0xD0, 0x87, 0x00 },
		{ 0xC2, 0xB0, 0x00 },{ 0xC2, 0xB1, 0x00 },{ 0xD0, 0x86, 0x00 },{ 0xD1, 0x96, 0x00 },
		{ 0xD2, 0x91, 0x00 },{ 0xC2, 0xB5, 0x00 },{ 0xC2, 0xB6, 0x00 },{ 0xC2, 0xB7, 0x00 },
		{ 0xD1, 0x91, 0x00 },{ 0xE2, 0x84, 0x96, 0x00 },{ 0xD1, 0x94, 0x00 },{ 0xC2, 0xBB, 0x00 },
		{ 0xD1, 0x98, 0x00 },{ 0xD0, 0x85, 0x00 },{ 0xD1, 0x95, 0x00 },{ 0xD1, 0x97, 0x00 },
		{ 0xD0, 0x90, 0x00 },{ 0xD0, 0x91, 0x00 },{ 0xD0, 0x92, 0x00 },{ 0xD0, 0x93, 0x00 },
		{ 0xD0, 0x94, 0x00 },{ 0xD0, 0x95, 0x00 },{ 0xD0, 0x96, 0x00 },{ 0xD0, 0x97, 0x00 },
		{ 0xD0, 0x98, 0x00 },{ 0xD0, 0x99, 0x00 },{ 0xD0, 0x9A, 0x00 },{ 0xD0, 0x9B, 0x00 },
		{ 0xD0, 0x9C, 0x00 },{ 0xD0, 0x9D, 0x00 },{ 0xD0, 0x9E, 0x00 },{ 0xD0, 0x9F, 0x00 },
		{ 0xD0, 0xA0, 0x00 },{ 0xD0, 0xA1, 0x00 },{ 0xD0, 0xA2, 0x00 },{ 0xD0, 0xA3, 0x00 },
		{ 0xD0, 0xA4, 0x00 },{ 0xD0, 0xA5, 0x00 },{ 0xD0, 0xA6, 0x00 },{ 0xD0, 0xA7, 0x00 },
		{ 0xD0, 0xA8, 0x00 },{ 0xD0, 0xA9, 0x00 },{ 0xD0, 0xAA, 0x00 },{ 0xD0, 0xAB, 0x00 },
		{ 0xD0, 0xAC, 0x00 },{ 0xD0, 0xAD, 0x00 },{ 0xD0, 0xAE, 0x00 },{ 0xD0, 0xAF, 0x00 },
		{ 0xD0, 0xB0, 0x00 },{ 0xD0, 0xB1, 0x00 },{ 0xD0, 0xB2, 0x00 },{ 0xD0, 0xB3, 0x00 },
		{ 0xD0, 0xB4, 0x00 },{ 0xD0, 0xB5, 0x00 },{ 0xD0, 0xB6, 0x00 },{ 0xD0, 0xB7, 0x00 },
		{ 0xD0, 0xB8, 0x00 },{ 0xD0, 0xB9, 0x00 },{ 0xD0, 0xBA, 0x00 },{ 0xD0, 0xBB, 0x00 },
		{ 0xD0, 0xBC, 0x00 },{ 0xD0, 0xBD, 0x00 },{ 0xD0, 0xBE, 0x00 },{ 0xD0, 0xBF, 0x00 },
		{ 0xD1, 0x80, 0x00 },{ 0xD1, 0x81, 0x00 },{ 0xD1, 0x82, 0x00 },{ 0xD1, 0x83, 0x00 },
		{ 0xD1, 0x84, 0x00 },{ 0xD1, 0x85, 0x00 },{ 0xD1, 0x86, 0x00 },{ 0xD1, 0x87, 0x00 },
		{ 0xD1, 0x88, 0x00 },{ 0xD1, 0x89, 0x00 },{ 0xD1, 0x8A, 0x00 },{ 0xD1, 0x8B, 0x00 },
		{ 0xD1, 0x8C, 0x00 },{ 0xD1, 0x8D, 0x00 },{ 0xD1, 0x8E, 0x00 },{ 0xD1, 0x8F, 0x00 }
	};

	std::string r;
	if (len>0) r.reserve(2 * len);
	while (*data && len--) {
		if (*data & 0x80) r.append((const char*)(utf8enc1251[0x7F & *data]));
		else r.append(1, *data);
		++data;
	}
	return r;
};

#endif

}